import os
import json
import hashlib
import psycopg2
from psycopg2 import sql
from concurrent.futures import ThreadPoolExecutor, as_completed
from psycopg2.pool import SimpleConnectionPool
import subprocess

# PostgreSQL connection details
DB_NAME = '<DB_NAME>'
DB_USER = '<DB_USER>'
DB_PASSWORD = '<DB_PASSWORD>'
DB_HOST = '<DB_HOST>'
DB_PORT = '<DB_PORT>'

# CVE repository path
CVE_REPO_PATH = '<CVE_REPO_PATH>'
CVE_DIR = os.path.join(CVE_REPO_PATH, 'cves')

# Connection pool
connection_pool = SimpleConnectionPool(1, 10, dbname=DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST, port=DB_PORT)

# Function to calculate the hash of a file
def calculate_hash(file_path):
    hasher = hashlib.md5()
    with open(file_path, 'rb') as f:
        buf = f.read()
        hasher.update(buf)
    return hasher.hexdigest()

# Function to update the database with new or changed JSON files
def update_database(cve_id, file_path, file_hash):
    connection = connection_pool.getconn()
    if connection:
        cursor = connection.cursor()
        try:
            with open(file_path, 'r') as f:
                cve_data = json.load(f)

            # Check if the file has changed
            cursor.execute(sql.SQL("SELECT hash FROM file_hashes WHERE cve_id = %s"), [cve_id])
            result = cursor.fetchone()
            if result and result[0] == file_hash:
                print(f"File {cve_id} has not changed.")
            else:
                # Insert or update the file in the database
                cursor.execute(
                    sql.SQL("INSERT INTO cve_files (cve_id, hash, data) VALUES (%s, %s, %s) ON CONFLICT (cve_id) DO UPDATE SET hash = %s, data = %s"),
                    [cve_id, file_hash, json.dumps(cve_data), file_hash, json.dumps(cve_data)]
                )
                cursor.execute(
                    sql.SQL("INSERT INTO file_hashes (cve_id, hash) VALUES (%s, %s) ON CONFLICT (cve_id) DO UPDATE SET hash = %s"),
                    [cve_id, file_hash, file_hash]
                )
                connection.commit()
                print(f"File {cve_id} updated in the database.")
        except Exception as e:
            print(f"Error updating the database: {e}")
        finally:
            cursor.close()
            connection_pool.putconn(connection)

# Function to process a single file
def process_file(file_path):
    cve_id = os.path.splitext(os.path.basename(file_path))[0]  # Extract CVE ID from file name
    file_hash = calculate_hash(file_path)
    update_database(cve_id, file_path, file_hash)

# Function to pull the latest changes from the Git repository
def git_pull():
    try:
        subprocess.check_call(['git', 'pull'], cwd=CVE_REPO_PATH)
        print("Successfully pulled the latest changes from the Git repository.")
    except subprocess.CalledProcessError as e:
        print(f"Error pulling the latest changes from the Git repository: {e}")

# Main function to crawl the repository and update the database
def main():
    # Pull the latest changes from the Git repository
    git_pull()

    file_paths = []
    for root, dirs, files in os.walk(CVE_DIR):
        for file in files:
            if file.endswith('.json'):
                file_paths.append(os.path.join(root, file))

    with ThreadPoolExecutor(max_workers=10) as executor:
        futures = [executor.submit(process_file, file_path) for file_path in file_paths]
        for future in as_completed(futures):
            try:
                future.result()
            except Exception as e:
                print(f"Error processing file: {e}")

if __name__ == "__main__":
    main()
